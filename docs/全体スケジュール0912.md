20日ロードマップ（Dayごと手順 / “Cursorに投げる一言”付き）
Week1：フロント雛形→認証→ダッシュボード（Day1–5）

目標：/login → /dashboard（空） まで“いちから”組み上げる。

Day1：Next.jsプロジェクトを新規作成

npx create-next-app@latest --ts → Tailwind導入 → shadcn/ui init

/login ページのモック（Email/Password + Button）
Done：http://localhost:3000/login が開く（完全新規で作成）。
Cursor：「Next.js 14 + Tailwind + shadcn/ui で空のプロジェクトを作り、/login ページを作成して」

Day2：レイアウト・ヘッダ・フッタ

app/layout.tsx に共通ヘッダ/フッタ

app/(auth)/login/page.tsx と app/(app)/dashboard/page.tsx のルート分割
Done：未実装でも /dashboard に空カード表示。

Day3：Auth.js（NextAuth）導入（Credentials）

app/api/auth/[...nextauth]/route.ts を作成

.env.local に NEXTAUTH_SECRET、仮の NEXT_PUBLIC_API_BASE

signIn("credentials") でログイン成功時に /dashboard へ
Done：ダミー認証で /dashboard へ進める（まだAPIはモック）。
Cursor：「App RouterでNextAuth(Credentials)の最小構成を作り、/login 成功で /dashboard へ遷移して」

Day4：ダッシュボード骨格

/dashboard/layout.tsx でサイドバー＋トップバー

メニュー：Home / Vendors / Search / Settings

未ログイン時のリダイレクト（middleware or サーバーコンポーネントで getServerSession）
Done：ログイン後のみ /dashboard/* が閲覧可。
Cursor：「/dashboard配下をガードするmiddlewareと、サイドバーUIをshadcnで生成して」

Day5：見た目の整え（UIパーツ基礎）

フォーム、テーブル、カード、トーストなどshadcnコンポーネントを配置

「検索条件パネル」モック（k, MMR on/off, モデル選択）
Done：ダッシュボードに“空だが完成形の骨格UI”が見える。

Week2：バックエンド雛形→認証実体化→RAG最小（Day6–10）

目標：FastAPI雛形 → /auth/verify → /search(モック) → Next.jsから呼ぶ。

Day6：FastAPIを新規作成（完全いちから）

venv 作成、fastapi uvicorn pydantic をインストール

/health 実装、CORSで http://localhost:3000 許可
Done：GET /health が {"status":"ok"} を返す（新規）。
Cursor：「FastAPI最小アプリを新規作成し、/health とCORS設定を入れて」

Day7：DB層（まずはSQLite）→ /auth/register /auth/verify

SQLAlchemy + passlib[bcrypt] で User テーブル（id, email, password_hash, created_at）

/auth/register（開発用）→ /auth/verify（200/401）
Done：NextAuthの authorize() から /auth/verify を呼ぶと成功/失敗が分かる。
Cursor：「Userモデル/テーブルを作り、/auth/register & /auth/verify を実装して」

Day8：JWT共有（フロント→バックの保護）

NextAuthのJWTをFastAPIでも検証（HS256, NEXTAUTH_SECRET 共有）

get_current_user()で user_id/org_id を取得
Done：保護API（例 /me）がJWT必須で動く。
Cursor：「AuthorizationヘッダのJWTを検証して user_id/org_id を返す依存関数を書いて」

Day9：RAGパス最小（ローカル実装）

LangChain：Markdown読み込み→分割（Header/TextSplitter）→Chromaに埋め込み→類似検索（MMR切替）→LLM回答＋引用

FastAPI：POST /search（question→answer+sources）をモックでOK
Done：ローカルで5問程度の検索が通る。
Cursor：「LangChainでMarkdown→分割→Chroma→Retriever→回答＋引用を返す関数を作って」

Day10：Next.jsから /search を叩く

/dashboard/search のフォーム→/api/search Route Handler→ FastAPI /search

結果カード（要約／引用リンク／スコア表示）
Done：UIからRAGの最小回答が返る。

Week3：AWS化（EC2なし）＆pgvector移行の下地（Day11–15）

目標：フロントAmplify、バックLambda+API GW で外部公開。

Day11’（フロント公開・据え置き）

Amplify Hosting を GitHub main 連携でデプロイ（元計画どおり）。
NEXT_PUBLIC_API_BASE は後で ECS の ALB URL に差し替え。

Day12’（ECR×2 リポジトリ + CodeBuild）

ECR に ui / api の2リポジトリを作成。

CodeBuild を 2本（または mono-repo なら buildspec でマルチターゲット）にして、docker build & push（今日やった流れを踏襲）。

ベースイメージは ECR Public を使うとレート制限回避できる（Docker Hub 429 で学んだやつを標準化）。

Day13’（ECS: APIサービスを常駐化）

ECS クラスター(Fargate) に vendor2-api サービスを作成（FastAPI: :8000 など）。

Service Connect（名前解決）を有効化すると将来 UI→API を VPC 内名で呼べる。

ログは CloudWatch Logs に集約（/ecs/vendor2/api）。

Day14’（ALB+HTTPS で公開口を整備）

パブリック ALB を作成（80/443）。ACM 証明書を設定、80→443 リダイレクト。

ターゲットグループ（IP/HTTP）に API:8000 を登録、ヘルスチェック /health。

SGは「ALB からのみ API:8000 を許可」。外からの直叩きは不可に。

Amplify の NEXT_PUBLIC_API_BASE を ALB の https URL に変更（/search 等が動けばOK）。
（元計画の「Day13: UI→本番API接続」に相当）

Day15’（RDS pgvector）

既存計画通り RDS PostgreSQL + pgvector を作成し、API から接続。DDL/SQLAlchemy モデル定義。

Chroma→pgvector の抽象層（ポート）を用意して切替容易に（計画の踏襲）。

Day16’（S3 ingest API）

POST /ingest で S3 プレフィックス取り込み → 分割 → 埋め込み → pgvector 保存。

既存案を ECS 前提に置換（バッチは EventBridge + Fargate タスク で起動）。

Day17’（Secrets / CORS / 設定の外出し）

OpenAI/APIキーや DB URL は Secrets Manager or SSM Parameter Store。

タスク定義 secrets で環境変数へ注入（元の「SSM/Secretsで .env 撤去」を ECS 流に実装）。

Day18’（レート制限 / 監視）

WAF（ALB） で基本ルール＋国/IP 制御。

CloudWatch Dashboards/アラーム：ALB 4xx/5xx、ターゲットの 5xx、ECS CPU/Mem p95、ログエラー率。
（元計画の「レート制限／監視」を API GW ではなく ALB+WAF で実現）

Day19’（CI/CD & Blue/Green）

CodePipeline（or GitHub Actions）で main → CodeBuild → ECR → ECS Update。

ECS Blue/Green（CodeDeploy）で無停止リリース、ターゲットグループ2系で入替。

Day20’（ドメイン/HTTPS & Runbook）

Route53 + ACM で独自ドメインを ALB に割当（元計画の「独自ドメイン/HTTPS」を ALB 側へ）。

Runbook（復旧手順／ローリングバック／コスト予算）を整備。

リポジトリ標準（別プロジェクトでも“同じ方式”で回せる形）
repo/
├─ ui/          # Next.js（Amplify 直結）
│  ├─ amplify.yml（buildspec）
│  └─ src/...
├─ api/         # FastAPI（ECS Fargate）
│  ├─ Dockerfile
│  ├─ app/...
│  └─ buildspec.yaml（ECRへpush）
├─ infra/       # 将来：CDK/TF（ECR/ECS/ALB/RDS/S3/WAF）
└─ .github/workflows/（or CodePipeline）


共通タグ：Project=tak-vendor2-0912, Owner=takuya_suehiro

環境変数：API_BASE_URL（UI側）、DB_URL/OPENAI_API_KEY（API側：Secretsから注入）

デプロイ手順：docker build & push → aws ecs update-service --force-new-deployment