20日ロードマップ（Dayごと手順 / “Cursorに投げる一言”付き）
Week1：フロント雛形→認証→ダッシュボード（Day1–5）

目標：/login → /dashboard（空） まで“いちから”組み上げる。

Day1：Next.jsプロジェクトを新規作成

npx create-next-app@latest --ts → Tailwind導入 → shadcn/ui init

/login ページのモック（Email/Password + Button）
Done：http://localhost:3000/login が開く（完全新規で作成）。
Cursor：「Next.js 14 + Tailwind + shadcn/ui で空のプロジェクトを作り、/login ページを作成して」

Day2：レイアウト・ヘッダ・フッタ

app/layout.tsx に共通ヘッダ/フッタ

app/(auth)/login/page.tsx と app/(app)/dashboard/page.tsx のルート分割
Done：未実装でも /dashboard に空カード表示。

Day3：Auth.js（NextAuth）導入（Credentials）

app/api/auth/[...nextauth]/route.ts を作成

.env.local に NEXTAUTH_SECRET、仮の NEXT_PUBLIC_API_BASE

signIn("credentials") でログイン成功時に /dashboard へ
Done：ダミー認証で /dashboard へ進める（まだAPIはモック）。
Cursor：「App RouterでNextAuth(Credentials)の最小構成を作り、/login 成功で /dashboard へ遷移して」

Day4：ダッシュボード骨格

/dashboard/layout.tsx でサイドバー＋トップバー

メニュー：Home / Vendors / Search / Settings

未ログイン時のリダイレクト（middleware or サーバーコンポーネントで getServerSession）
Done：ログイン後のみ /dashboard/* が閲覧可。
Cursor：「/dashboard配下をガードするmiddlewareと、サイドバーUIをshadcnで生成して」

Day5：見た目の整え（UIパーツ基礎）

フォーム、テーブル、カード、トーストなどshadcnコンポーネントを配置

「検索条件パネル」モック（k, MMR on/off, モデル選択）
Done：ダッシュボードに“空だが完成形の骨格UI”が見える。

Week2：バックエンド雛形→認証実体化→RAG最小（Day6–10）

目標：FastAPI雛形 → /auth/verify → /search(モック) → Next.jsから呼ぶ。

Day6：FastAPIを新規作成（完全いちから）

venv 作成、fastapi uvicorn pydantic をインストール

/health 実装、CORSで http://localhost:3000 許可
Done：GET /health が {"status":"ok"} を返す（新規）。
Cursor：「FastAPI最小アプリを新規作成し、/health とCORS設定を入れて」

Day7：DB層（まずはSQLite）→ /auth/register /auth/verify

SQLAlchemy + passlib[bcrypt] で User テーブル（id, email, password_hash, created_at）

/auth/register（開発用）→ /auth/verify（200/401）
Done：NextAuthの authorize() から /auth/verify を呼ぶと成功/失敗が分かる。
Cursor：「Userモデル/テーブルを作り、/auth/register & /auth/verify を実装して」

Day8：JWT共有（フロント→バックの保護）

NextAuthのJWTをFastAPIでも検証（HS256, NEXTAUTH_SECRET 共有）

get_current_user()で user_id/org_id を取得
Done：保護API（例 /me）がJWT必須で動く。
Cursor：「AuthorizationヘッダのJWTを検証して user_id/org_id を返す依存関数を書いて」

Day9：RAGパス最小（ローカル実装）

LangChain：Markdown読み込み→分割（Header/TextSplitter）→Chromaに埋め込み→類似検索（MMR切替）→LLM回答＋引用

FastAPI：POST /search（question→answer+sources）をモックでOK
Done：ローカルで5問程度の検索が通る。
Cursor：「LangChainでMarkdown→分割→Chroma→Retriever→回答＋引用を返す関数を作って」

Day10：Next.jsから /search を叩く

/dashboard/search のフォーム→/api/search Route Handler→ FastAPI /search

結果カード（要約／引用リンク／スコア表示）
Done：UIからRAGの最小回答が返る。

Week3：AWS化（EC2なし）＆pgvector移行の下地（Day11–15）

目標：フロントAmplify、バックLambda+API GW で外部公開。

Day11：Amplify Hosting（フロント）

GitHub連携→ビルド→公開URL取得

環境変数 NEXT_PUBLIC_API_BASE を後で設定（API完成後）
Done：AmplifyのURLで /login / /dashboard が見える。
Cursor：「Amplifyのbuildspec.ymlと環境変数の設定例を生成して」

Day12：Lambda + API Gateway（バック）

FastAPIを Mangum でLambda化、handler.py 作成

API GW HTTP APIで ANY /{proxy+} → Lambda

CORS：AmplifyのURLを許可
Done：curl で …/health が200。
Cursor：「FastAPI+MangumのLambda用ZIP作成と、API Gateway統合手順のコマンド群を書いて」

Day13：Stream（UI）→API（本番）接続

Amplifyの環境変数に NEXT_PUBLIC_API_BASE=https://<api-id>.execute-api...

/dashboard/search から本番APIを叩く
Done：Amplify URL上で検索が動作。

Day14：RDS PostgreSQL + pgvector（設計/接続）

RDS作成（pgvector拡張有効化）

DDL（documents, chunks(embedding vector(1536)) など）・SQLAlchemyモデル

「Chroma→pgvector」の抽象層（VectorStorePort）を用意
Done：ローカルからRDSにINSERT/SELECTできる。
Cursor：「pgvector用のDDL/モデルと、Chromaと差し替え可能なインタフェース実装を生成して」

Day15：S3取り込み & /ingest

POST /ingest {prefix} → S3のMarkdownを列挙→分割→埋め込み→pgvector保存

既存データの再取り込み抑制（ETag/updated_at）
Done：S3投入→/ingest→検索反映まで一連で通る。

Week4：運用性・整備（Day16–20）

目標：公開に耐える最小運用（鍵・ログ・Rate Limit・Runbook）。

Day16：SSM / Secrets / CORS最終化

OpenAIキー・DB URL を SSM Parameter Store へ

Lambda/Next.jsから参照（環境変数バインド）
Done：.envを撤去しても動く。

Day17：レート制限／監視

API GWのレート制限（Burst/Rate）

CloudWatch Logs + 簡易メトリクス（p95, エラー率, トークン使用量）
Done：乱用対策＆エラー可視化。

Day18：UI磨き & “わからない”戦略

MMR/類似度の閾値、引用ゼロ時は「わからない」を返すポリシー

ダッシュボードのカード見栄え調整、ローディング/トースト
Done：体験の荒れを解消。

Day19：スモークテスト & README/FAQ

シナリオ：S3投入→/ingest→検索→再投入→再検索

README（環境変数、デプロイ、復旧手順）
Done：誰が触っても再現できる。

Day20：独自ドメイン/HTTPS & リリースノート

Amplify / API GW に独自ドメイン（Route53 + ACM）

リリースノート：機能・既知の制約・次の一手
Done：公開URL（HTTPS） と運用Runbookが揃う。